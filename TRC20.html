<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRC20 Token Claimer</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            text-align: center; 
            padding: 20px; 
            background-color: #f2f2f2;
        }
        h1 {
            margin-bottom: 0;
        }
        p {
            font-size: 16px;
            margin: 20px auto;
            max-width: 600px;
            line-height: 1.6;
        }
        a {
            color: #007BFF;
            text-decoration: none;
        }
        a:hover, a:focus {
            text-decoration: underline;
        }
        button, input { 
            margin: 10px; 
            padding: 20px 30px;
            cursor: pointer; 
            border-radius: 8px;
            border: none;
        }
        button:not(.disabled) { 
            background-color: #4CAF50; 
            color: white;
        }
        .disabled { 
            background-color: #ccc; 
            color: #666;
            cursor: not-allowed;
        }
        #tokens { 
            display: none;
        }
        @media (max-width: 768px) {
            p {
                font-size: 14px;
                padding: 0 10px;
            }
            button, input {
                padding: 15px 20px;
            }
        }
        #whitelistMessage {
            display: none;
            color: red;
            font-size: 18px;
            margin-top: 20px;
        }
        #cooldownTimer {
            color: red;
            font-size: 18px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>TRC20 Token Claimer</h1>

    <p>Claim TRC20 tokens once every 24 hours. Energy is consumed from users addresses, so make sure the claimable amount is worth claiming. Tokens accumulate every minute. Will you claim now or risk someone else claiming before you? If you need Energy, you can <a href="https://tronnrg.com/r/TXgL1i4dF1vEhDYuVsMuo8ovcfdEE6tztA" target="_blank">rent it from TronNRG</a>.</p>

    <button id="connectWallet">Connect TronLink Wallet</button>

    <p id="whitelistMessage">Contact Stian_86 on Telegram to be whitelisted for this page.</p>

    <div id="tokens">
        <div>
            <p id="token1Name">Token 1:</p>
            <p id="claimableAmount1">Claimable Amount: 0</p>
            <button id="claimToken1" onclick="claimToken('TSknFHj7ej6qP86dJFYkGVxVeH5x1CM6D1')">Claim</button>
        </div>
        <div>
            <p id="token2Name">Token 2:</p>
            <p id="claimableAmount2">Claimable Amount: 0</p>
            <button id="claimToken2" onclick="claimToken('TWRJ4z9BnERjx9gKzBT9GkiCbPYmWCc4jb')">Claim</button>
        </div>
        <p id="cooldownTimer"></p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/tronweb/dist/TronWeb.js"></script>
    <script>
        let tronWeb;
        const contractAddress = "TDz3ou9AzJZL4W8if5rMP5pqkqeDqbfGJX";
        const contractABI = [
            {"constant": true,"inputs": [],"name": "owner","outputs": [{"name": "", "type": "address"}],"payable": false,"stateMutability": "view","type": "function"},
            {"constant": true,"inputs": [{"name": "_tokenAddr", "type": "address"}],"name": "viewAccumulatedAmount","outputs": [{"name": "", "type": "uint256"}],"payable": false,"stateMutability": "view","type": "function"},
            {"constant": false,"inputs": [{"name": "_tokenAddr", "type": "address"}],"name": "claimTokens","outputs": [],"payable": false,"stateMutability": "nonpayable","type": "function"},
            {"constant": true,"inputs": [{"name": "account", "type": "address"}],"name": "isWhitelisted","outputs": [{"name": "", "type": "bool"}],"payable": false,"stateMutability": "view","type": "function"},
            {"constant": true,"inputs": [],"name": "claimCooldown","outputs": [{"name": "", "type": "uint256"}],"payable": false,"stateMutability": "view","type": "function"},
            {"constant": true,"inputs": [{"name": "_tokenAddr", "type": "address"}],"name": "lastClaimTimePerToken","outputs": [{"name": "", "type": "uint256"}],"payable": false,"stateMutability": "view","type": "function"},
            {"constant": true,"inputs": [{"name": "_tokenAddr", "type": "address"}],"name": "accumulationRatePerMinute","outputs": [{"name": "", "type": "uint256"}],"payable": false,"stateMutability": "view","type": "function"}
        ];

        const tokenAddresses = {
            'TSknFHj7ej6qP86dJFYkGVxVeH5x1CM6D1': 'claimToken1',
            'TWRJ4z9BnERjx9gKzBT9GkiCbPYmWCc4jb': 'claimToken2'
        };

        window.addEventListener('load', function() {
            if (typeof window.tronWeb === 'undefined') {
                console.log("Waiting for TronLink...");
                setTimeout(startApp, 1000);
            } else {
                startApp();
            }
        });

        function startApp() {
            tronWeb = window.tronWeb;
            if (!tronWeb.defaultAddress.base58) {
                console.log('Please log in to TronLink.');
                return;
            }
            console.log('TronLink connected. Wallet Address:', tronWeb.defaultAddress.base58);
            checkWhitelist(tronWeb.defaultAddress.base58);
        }

        document.getElementById('connectWallet').addEventListener('click', function() {
            if (window.tronWeb && window.tronWeb.defaultAddress.base58) {
                alert('Wallet connected: ' + tronWeb.defaultAddress.base58);
                checkWhitelist(tronWeb.defaultAddress.base58);
            } else {
                alert('Please install TronLink or log in.');
            }
        });

        async function checkWhitelist(address) {
            try {
                const contract = await tronWeb.contract(contractABI, contractAddress);
                const isWhitelisted = await contract.isWhitelisted(address).call();
                if (isWhitelisted) {
                    document.getElementById('tokens').style.display = 'block';
                    document.getElementById('connectWallet').innerText = 'Connected';
                    document.getElementById('whitelistMessage').style.display = 'none';
                    fetchTokenNames();
                    updateClaimableAmounts();
                    updateCooldownTimers();
                    setInterval(updateClaimableAmounts, 10000); // Updates every 10 seconds
                    setInterval(updateCooldownTimers, 1000); // Updates every second
                } else {
                    document.getElementById('tokens').style.display = 'none';
                    document.getElementById('whitelistMessage').style.display = 'block';
                }
            } catch (error) {
                console.error('Error checking whitelist status:', error);
            }
        }

        async function fetchTokenNames() {
            for (const [address, buttonId] of Object.entries(tokenAddresses)) {
                try {
                    const tokenContract = await tronWeb.contract(contractABI, address);
                    const tokenName = await tokenContract.name().call();
                    document.getElementById(buttonId).innerText = `Claim ${tokenName}`;
                } catch (error) {
                    console.error(`Error fetching name for token ${address}:`, error);
                }
            }
        }

        async function updateClaimableAmounts() {
            const contract = await tronWeb.contract(contractABI, contractAddress);
            for (const [address, amountElementId] of Object.entries(tokenAddresses)) {
                try {
                    const amount = await contract.viewAccumulatedAmount(address).call();
                    const formattedAmount = tronWeb.toBigNumber(amount).div(1e6).toFixed(0);
                    document.getElementById(`claimableAmount${Object.keys(tokenAddresses).indexOf(address) + 1}`).innerText = 'Claimable Amount: ' + formattedAmount;
                } catch (error) {
                    console.error(`Error fetching amount for token ${address}:`, error);
                }
            }
        }

        async function updateCooldownTimers() {
            const contract = await tronWeb.contract(contractABI, contractAddress);
            const cooldownTime = (await contract.claimCooldown().call()).toNumber();

            let latestClaimTime = 0;
            for (const address of Object.keys(tokenAddresses)) {
                try {
                    const lastClaimTime = (await contract.lastClaimTimePerToken(address).call()).toNumber();
                    if (lastClaimTime > latestClaimTime) {
                        latestClaimTime = lastClaimTime;
                    }
                } catch (error) {
                    console.error(`Error fetching last claim time for token ${address}:`, error);
                }
            }

            const now = Math.floor(Date.now() / 1000);
            const timeLeft = (latestClaimTime + cooldownTime) - now;

            const cooldownTimer = document.getElementById('cooldownTimer');
            const claimButtons = document.querySelectorAll('button[id^="claimToken"]');

            if (timeLeft > 0) {
                const hours = Math.floor(timeLeft / 3600);
                const minutes = Math.floor((timeLeft % 3600) / 60);
                const seconds = timeLeft % 60;
                cooldownTimer.innerText = `Cooldown: ${hours}h ${minutes}m ${seconds}s`;
                claimButtons.forEach(button => {
                    button.classList.add('disabled');
                    button.disabled = true;
                });
            } else {
                cooldownTimer.innerText = '';
                claimButtons.forEach(button => {
                    button.classList.remove('disabled');
                    button.disabled = false;
                });
            }
        }

        async function claimToken(tokenAddress) {
            try {
                const contract = await tronWeb.contract(contractABI, contractAddress);
                console.log('Claiming tokens for address:', tokenAddress);
                const result = await contract.claimTokens(tokenAddress).send({
                    from: tronWeb.defaultAddress.base58
                });

                console.log('Claim transaction result:', result);
                alert('Claim successful! Transaction ID: ' + result);
                updateCooldownTimers();
                updateClaimableAmounts();
            } catch (error) {
                console.error('Claim failed:', error);
                alert('Claim failed: ' + error.message);
            }
        }
    </script>
</body>
</html>
